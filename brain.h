#ifndef NN_H
#define NN_H

#include <iostream>
#include <vector>
#include <cmath>
#include <eigen3/Eigen/Dense>
#include <eigen3/unsupported/Eigen/MatrixFunctions>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <map>
#include <type_traits>
#include <limits>
#include <string>

class FCM {
private:
    int index;
    double V_rest = -70.0;
    double V_thresh = -30.0;
    double E_l = -81.4;
    double Cm = 1.0;

    double E_po = -77.0;
    double E_Na = 50.0;
    double E_ca = 120.0;
    double E_HC = -40.0;
    double E_ct = 22.6;
    double RA = 0.1;
    double ro_ex = 1.0;

    double K_m_Na, K_h_Na, K_s_Na, K_m_Ca_T, K_h_Ca_T;
    double K_n_K_fast, K_n_K_slow, K_c_Ca_L, K_y_HCN;

    Eigen::MatrixXd Con_Mat;
    Eigen::VectorXd surfaces;
    int num_rows;

    Eigen::MatrixXd Vm;
    std::map<std::string, Eigen::VectorXd> channel_states;

    Eigen::VectorXd gbar_l_vec, gbar_Na_vec, gbar_ca_vec;
    Eigen::VectorXd gbar_kd_vec, gbar_k7_vec, gbar_HC_vec, gbar_ct_vec;

public:
    // Constructor
    FCM(const std::string& model_path = "morphology_FCM.swc");

    // Setter method
    void set_index(int new_index);

    // Spike detection method
    bool spiked();

    // Simulation step method
    std::map<std::string, double> step(double curr_input, double dt = 0.01);

    // Helper methods for channel kinetics
    double alpha_n_K_fast(double v);
    double beta_n_K_fast(double v);
    double alpha_n_K_slow(double v);
    double beta_n_K_slow(double v);
    double n_K_fast_inf(double v);
    double tau_n_K_fast(double v);
    double n_K_slow_inf(double v);
    double tau_n_K_slow(double v);
    double m_Na_inf(double v);
    double h_Na_inf(double v);
    double s_Na_inf(double v);
    double tau_m_Na(double v);
    double tau_h_Na(double v);
    double tau_s_Na(double v);
    double m_Ca_T_inf(double v);
    double h_Ca_T_inf(double v);
    double tau_m_Ca_T(double v);
    std::vector<double> tau_h_Ca_T(const std::vector<double>& v);
    double alpha_y_HCN(double v);
    double beta_y_HCN(double v);
    double y_HCN_inf(double v);
    double tau_y_HCN(double v);

    // Template method for alpha_c_Ca_L
    template <typename T>
    auto alpha_c_Ca_L(const T& v);

    double beta_c_Ca_L(double v);
    double c_Ca_L_inf(double v);
    double tau_c_Ca_L(double v);
};

class Synapse {
private:
    FCM* pre_neuron;   // Presynaptic neuron
    FCM* post_neuron;  // Postsynaptic neuron
    double weight;        // Synaptic weight
    double delay;         // Synapse relaxation delay in ms
    double tau;           // Time constant for synaptic current decay in ms
    std::string syn_type; // Type of synapse: "excitatory" or "inhibitory"
    double syn_current;   // Current generated by the synapse
    double last_spike_time; // Last time the presynaptic neuron spiked

public:
    // Constructor to initialize the synapse
    Synapse(FCM* pre, 
        FCM* post, 
        double weight = 0.1, 
        double delay = 1.0, 
        double tau = 5.0, 
        const std::string& type = "excitatory");

    // Method to update the synaptic current
    void step(double t, double dt);

    // Method to get the current generated by the synapse
    double get_current() const;

    // Get synapse type
    std::string get_type() const;

    // Get postsynaptic neuron
    FCM* get_post_neuron();

    // Get presynaptic neuron
    FCM* get_pre_neuron();
};

class Network {
public:
    // Containers for neurons, synapses, and input currents
    std::vector<FCM*> neurons;
    std::vector<Synapse*> synapses;
    std::vector<double> input_currents;

    // Default constructor
    Network();
    int num_neurons();
    int add_neuron();

    void connect(int pre_index,
                 int post_index,
                 double weight = 0.1,
                 double delay = 1.0,
                 double tau = 5.0,
                 std::string syn_type = "excitatory");

    std::vector<double> step(std::vector<double>& external_current, 
                              double t, 
                              double dt);
};

#endif // NN_H